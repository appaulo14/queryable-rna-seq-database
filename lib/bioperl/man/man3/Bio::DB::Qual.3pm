.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Qual 3"
.TH Bio::DB::Qual 3 "2012-12-24" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Qual \-\- Fast indexed access to a directory of quality files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::DB::Qual;
\&
\&  # create database from directory of qual files
\&  my $db      = Bio::DB::Qual\->new(\*(Aq/path/to/qual/files\*(Aq);
\&  my @ids     = $db\->ids;
\&
\&  # simple access (for those without Bioperl)
\&  my @qual    = @{$db\->qual(\*(AqCHROMOSOME_I\*(Aq,4_000_000 => 4_100_000)};
\&  my @revqual = @{$db\->qual(\*(AqCHROMOSOME_I\*(Aq,4_100_000 => 4_000_000)};
\&  my $length  = $db\->length(\*(AqCHROMOSOME_I\*(Aq);
\&  my $header  = $db\->header(\*(AqCHROMOSOME_I\*(Aq);
\&
\&  # Bioperl\-style access
\&  my $obj     = $db\->get_Qual_by_id(\*(AqCHROMOSOME_I\*(Aq);
\&  my @qual    = @{$obj\->qual};
\&  my @subqual = @{$obj\->subqual(4_000_000 => 4_100_000)};
\&  my $length  = $obj\->length;
\&  # (etc)
\&
\&  # Bio::SeqIO\-style access
\&  my $stream  = $db\->get_PrimaryQual_stream;
\&  while (my $qual = $stream\->next_seq) {
\&    # Bio::Seq::PrimaryQual operations
\&  }
\&
\&  my $fh = Bio::DB::Qual\->newFh(\*(Aq/path/to/qual/files\*(Aq);
\&  while (my $qual = <$fh>) {
\&    # Bio::Seq::PrimaryQual operations
\&  }
\&
\&  # tied hash access
\&  tie %qualities,\*(AqBio::DB::Qual\*(Aq,\*(Aq/path/to/qual/files\*(Aq;
\&  print $qualities{\*(AqCHROMOSOME_I:1,20000\*(Aq};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::Qual provides indexed access to one or more qual files. It provides
random access to each quality score entry without having to read the file from
the beginning. Access to subqualities (portions of a quality score) is provided,
although contrary to Bio::DB::Fasta, the full quality score has to be brought in
memory.
.PP
When you initialize the module, you point it at a single qual file or a
directory of multiple such files. The first time it is run, the module generates
an index of the contents of the file or directory using the AnyDBM module
(Berkeley DB* preferred, followed by GDBM_File, NDBM_File, and SDBM_File).
Thereafter it uses the index file to find the file and offset for any requested
quality score. If one of the source qual files is updated, the module reindexes
just that one file. (You can also force reindexing manually). For improved
performance, the module keeps a cache of open filehandles, closing less-recently
used ones when the cache is full.
.PP
The qual files may contain decimal quality scores. Entries may have any line
length up to 65,536 characters, and different line lengths are allowed in the
same file. However, within a quality score entry, all lines must be the same
length except for the last. An error will be thrown if this is not the case.
.PP
The module uses /^>(\eS+)/ to extract the primary \s-1ID\s0 of each quality score
from the qual header. During indexing, you may pass a callback routine to modify
this primary \s-1ID\s0.  For example, you may wish to extract a portion of the
gi|gb|abc|xyz prefixes that are commonly used. The original header line can be
recovered later.
.PP
*Berkeley \s-1DB\s0 can be obtained free from www.sleepycat.com. After it is installed
you will need to install the BerkeleyDB Perl module.
.SH "DATABASE CREATION AND INDEXING"
.IX Header "DATABASE CREATION AND INDEXING"
The two constructors for this class are \fInew()\fR and \fInewFh()\fR. The former creates a
Bio::DB::Qual object which is accessed via method calls. The latter creates a
tied filehandle which can be used Bio::SeqIO\-style to fetch quality score
objects in a data stream. There is also a tied hash interface.
.ie n .IP "$db = Bio::DB::Qual\->new($qual_path [,%options])" 2
.el .IP "\f(CW$db\fR = Bio::DB::Qual\->new($qual_path [,%options])" 2
.IX Item "$db = Bio::DB::Qual->new($qual_path [,%options])"
Create a new Bio::DB::Qual object from the Qual file or files indicated by
\&\f(CW$qual_path\fR. Indexing will be performed automatically if needed. If successful,
\&\fInew()\fR will return the database accessor object. Otherwise it will return undef.
.Sp
\&\f(CW$qual_path\fR may be an individual qual file, or may refer to a directory
containing one or more of such files. Following the path, you may pass a series
of name=>value options or a hash with these same name=>value pairs. 
Valid options are:
.Sp
.Vb 2
\& Option Name   Description               Default
\& \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-               \-\-\-\-\-\-\-
\&
\& \-glob         Glob expression to use    *.{qa,QA,qual,QUAL}
\&               for searching for qual
\&               files in directories. 
\&
\& \-makeid       A code subroutine for     None
\&               transforming qual IDs.
\&
\& \-maxopen      Maximum size of           32
\&               filehandle cache.
\&
\& \-debug        Turn on status            0
\&               messages.
\&
\& \-reindex      Force the index to be     0
\&               rebuilt.
\&
\& \-dbmargs      Additional arguments      none
\&               to pass to the DBM
\&               routines when tied
\&               (scalar or array ref).
.Ve
.Sp
\&\-dbmargs can be used to control the format of the index. For example, you can
pass \f(CW$DB_BTREE\fR to this argument so as to force the IDs to be sorted and
retrieved alphabetically. Note that you must use the same arguments every time
you open the index!
.Sp
\&\-reindex can be used to force the index to be recreated from scratch.
.ie n .IP "$fh = Bio::DB::Qual\->newFh($qual_path [,%options])" 2
.el .IP "\f(CW$fh\fR = Bio::DB::Qual\->newFh($qual_path [,%options])" 2
.IX Item "$fh = Bio::DB::Qual->newFh($qual_path [,%options])"
Create a tied filehandle opened on a Bio::DB::Qual object. Reading from this
filehandle with <> will return a stream of quality objects,
Bio::SeqIO\-style.
.PP
The \-makeid option gives you a chance to modify quality score IDs during
indexing. The option value should be a code reference that will take a scalar
argument and return a scalar result, like this:
.PP
.Vb 1
\&  $db = Bio::DB::Qual\->new("file.qual",\-makeid=>\e&make_my_id);
\&
\&  sub make_my_id {
\&    my $description_line = shift;
\&    # get a different id from the quality header, e.g.
\&    $description_line =~ /(\eS+)$/;
\&    return $1;
\&  }
.Ve
.PP
\&\fImake_my_id()\fR will be called with the full qual id line (including the \*(L">\*(R"
symbol!). For example:
.PP
.Vb 1
\&  >A12345.3 Predicted C. elegans protein egl\-2
.Ve
.PP
By default, this module will use the regular expression /^>(\eS+)/ to extract
\&\*(L"A12345.3\*(R" for use as the \s-1ID\s0.If you pass a \-makeid callback, you can extract any
portion of this, such as the \*(L"egl\-2\*(R" symbol.
.PP
The \-makeid option is ignored after the index is constructed.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
The following object methods are provided.
.ie n .IP "$raw_qual = $db\->qual($id [,$start, $stop])" 10
.el .IP "\f(CW$raw_qual\fR = \f(CW$db\fR\->qual($id [,$start, \f(CW$stop\fR])" 10
.IX Item "$raw_qual = $db->qual($id [,$start, $stop])"
Return a quality score array reference given an \s-1ID\s0 and optionally a start and
stop position (the quality value number) in the quality score. If \f(CW$stop\fR is less
than \f(CW$start\fR, then the reverse complement of the quality score is returned (this
violates Bio::Seq conventions).
.Sp
For your convenience, subqualities can be indicated with any of the following
compound IDs:
.Sp
.Vb 1
\&   $db\->qual("$id:$start,$stop")
\&
\&   $db\->qual("$id:$start..$stop")
\&
\&   $db\->qual("$id:$start\-$stop")
.Ve
.ie n .IP "$length = $db\->length($id)" 10
.el .IP "\f(CW$length\fR = \f(CW$db\fR\->length($id)" 10
.IX Item "$length = $db->length($id)"
Return the length of the indicated quality score, i.e. the number of quality
values.
.ie n .IP "$header = $db\->header($id)" 10
.el .IP "\f(CW$header\fR = \f(CW$db\fR\->header($id)" 10
.IX Item "$header = $db->header($id)"
Return the header line for the \s-1ID\s0, including the initial \*(L">\*(R".
.ie n .IP "$filename  = $db\->file($id)" 10
.el .IP "\f(CW$filename\fR  = \f(CW$db\fR\->file($id)" 10
.IX Item "$filename  = $db->file($id)"
Return the name of the file in which the indicated quality score can be found.
.ie n .IP "$offset    = $db\->offset($id)" 10
.el .IP "\f(CW$offset\fR    = \f(CW$db\fR\->offset($id)" 10
.IX Item "$offset    = $db->offset($id)"
Return the offset of the indicated quality score from the beginning of the file
in which it is located.  The offset points to the beginning of the quality
score, not the beginning of the header line.
.ie n .IP "$header_length = $db\->headerlen($id)" 10
.el .IP "\f(CW$header_length\fR = \f(CW$db\fR\->headerlen($id)" 10
.IX Item "$header_length = $db->headerlen($id)"
Return the length of the header line for the indicated quality score.
.ie n .IP "$header_offset = $db\->header_offset($id)" 10
.el .IP "\f(CW$header_offset\fR = \f(CW$db\fR\->header_offset($id)" 10
.IX Item "$header_offset = $db->header_offset($id)"
Return the offset of the header line for the indicated quality score from the
beginning of the file in which it is located.
.ie n .IP "$index_name  = $db\->index_name" 10
.el .IP "\f(CW$index_name\fR  = \f(CW$db\fR\->index_name" 10
.IX Item "$index_name  = $db->index_name"
Return the path to the index file.
.ie n .IP "$path = $db\->path" 10
.el .IP "\f(CW$path\fR = \f(CW$db\fR\->path" 10
.IX Item "$path = $db->path"
Return the path to the Qual file(s).
.PP
For BioPerl-style access, the following methods are provided:
.ie n .IP "$qual = $db\->get_Qual_by_id($id)" 4
.el .IP "\f(CW$qual\fR = \f(CW$db\fR\->get_Qual_by_id($id)" 4
.IX Item "$qual = $db->get_Qual_by_id($id)"
Return a Bio::Seq::PrimaryQual object, which obeys the Bio::PrimarySeqI 
conventions. To recover the quality score, call \f(CW$qual\fR\->\fIqual()\fR.
.Sp
Note that \fIget_Qual_by_id()\fR does not bring the entire quality score into memory
until requested. Internally, the returned object uses the accessor to generate
subqualities as needed.
.ie n .IP "$qual = $db\->get_Qual_by_acc($id)" 4
.el .IP "\f(CW$qual\fR = \f(CW$db\fR\->get_Qual_by_acc($id)" 4
.IX Item "$qual = $db->get_Qual_by_acc($id)"
.PD 0
.ie n .IP "$qual = $db\->get_Qual_by_primary_id($id)" 4
.el .IP "\f(CW$qual\fR = \f(CW$db\fR\->get_Qual_by_primary_id($id)" 4
.IX Item "$qual = $db->get_Qual_by_primary_id($id)"
.PD
These methods all do the same thing as \fIget_Qual_by_id()\fR.
.ie n .IP "$stream = $db\->\fIget_PrimaryQual_stream()\fR" 4
.el .IP "\f(CW$stream\fR = \f(CW$db\fR\->\fIget_PrimaryQual_stream()\fR" 4
.IX Item "$stream = $db->get_PrimaryQual_stream()"
Return a Bio::DB::Qual::Stream object, which supports a single method 
\&\fInext_seq()\fR. Each call to \fInext_seq()\fR returns a new Bio::Seq::PrimaryQual object,
until no more quality scores remain.
.PP
See Bio::Seq::PrimaryQual and Bio::PrimarySeqI for methods provided by the
quality objects returned from \fIget_Qual_by_id()\fR and \fIget_PrimaryQual_stream()\fR.
.SH "TIED INTERFACES"
.IX Header "TIED INTERFACES"
This module provides two tied interfaces, one which allows you to treat the
quality score database as a hash, and the other which allows you to treat the
database as an I/O stream.
.SS "Creating a Tied Hash"
.IX Subsection "Creating a Tied Hash"
The tied hash interface is very straightforward.
.ie n .IP "$obj = tie %db,'Bio::DB::Qual','/path/to/qual/files' [,@args]" 1
.el .IP "\f(CW$obj\fR = tie \f(CW%db\fR,'Bio::DB::Qual','/path/to/qual/files' [,@args]" 1
.IX Item "$obj = tie %db,'Bio::DB::Qual','/path/to/qual/files' [,@args]"
Tie \f(CW%db\fR to Bio::DB::Qual using the indicated path to the Qual files. The
optional \f(CW@args\fR list is the same set of named argument/value pairs used by
Bio::DB::Qual\->\fInew()\fR.
.Sp
If successful, \fItie()\fR will return the tied object.  Otherwise it will return
undef.
.PP
Once tied, you can use the hash to retrieve an individual quality score by its
\&\s-1ID\s0, like this:
.PP
.Vb 1
\&  my $qual = $db{CHROMOSOME_I};
.Ve
.PP
You may select a subquality by appending the comma-separated range to the
quality score \s-1ID\s0 in the format \*(L"$id:$start,$stop\*(R". For example, here is the
first 1000 quality values of the quality score with \s-1ID\s0 \*(L"\s-1CHROMOSOME_I\s0\*(R":
.PP
.Vb 1
\&  my $qual = $db{\*(AqCHROMOSOME_I:1,1000\*(Aq};
.Ve
.PP
(The regular expression used to parse this format allows quality score IDs to
contain colons.)
.PP
When selecting subqualities, if \f(CW$start\fR > stop, then the reverse complement
will be returned.
.PP
The \fIkeys()\fR and \fIvalues()\fR functions will return the IDs and their quality scores,
respectively. In addition, \fIeach()\fR can be used to iterate over the entire data
set:
.PP
.Vb 3
\& while (my ($id,$quality) = each %db) {
\&    print "$id => $quality\en";
\& }
.Ve
.PP
When dealing with very large quality scores, you can avoid bringing them into
memory by calling \fIeach()\fR in a scalar context. This returns the key only. You can
then use tied(%db) to recover the Bio::DB::Qual object and call its methods.
.PP
.Vb 4
\& while (my $id = each %db) {
\&    print "$id => $db{$quality:1,100}\en";
\&    print "$id => ",tied(%db)\->length($id),"\en";
\& }
.Ve
.PP
You may, in addition invoke Bio::DB::Qual the \s-1FIRSTKEY\s0 and \s-1NEXTKEY\s0 tied hash
methods directly.
.ie n .IP "$id = $db\->\s-1FIRSTKEY\s0" 2
.el .IP "\f(CW$id\fR = \f(CW$db\fR\->\s-1FIRSTKEY\s0" 2
.IX Item "$id = $db->FIRSTKEY"
Return the first \s-1ID\s0 in the database.
.ie n .IP "$id = $db\->\s-1NEXTKEY\s0($id)" 2
.el .IP "\f(CW$id\fR = \f(CW$db\fR\->\s-1NEXTKEY\s0($id)" 2
.IX Item "$id = $db->NEXTKEY($id)"
Given an \s-1ID\s0, return the next quality score \s-1ID\s0.
.PP
This allows you to write the following iterative loop using just the object\-
oriented interface:
.PP
.Vb 4
\& my $db = Bio::DB::Qual\->new(\*(Aq/path/to/qual/files\*(Aq);
\& for (my $id=$db\->FIRSTKEY; $id; $id=$db\->NEXTKEY($id)) {
\&    # do something with quality
\& }
.Ve
.SS "Creating a Tied Filehandle"
.IX Subsection "Creating a Tied Filehandle"
The Bio::DB::Qual\->\fInewFh()\fR method creates a tied filehandle from which you
can read Bio::Seq::PrimaryQual quality score objects sequentially. The following
bit of code will iterate sequentially over all quality scores in the database:
.PP
.Vb 4
\& my $fh = Bio::DB::Qual\->newFh(\*(Aq/path/to/qual/files\*(Aq);
\& while (my $qual = <$fh>) {
\&   print $qual\->id,\*(Aq => \*(Aq,$qual\->length,"\en";
\& }
.Ve
.PP
When no more quality scores remain to be retrieved, the stream will return
undef.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
When a quality score is deleted from one of the qual files, this deletion is not
detected by the module and removed from the index. As a result, a \*(L"ghost\*(R" entry
will remain in the index and will return garbage results if accessed. Currently,
the only way to accomodate deletions is to rebuild the entire index, either by
deleting it manually, or by passing \-reindex=>1 to \fInew()\fR when
initializing the module.
.PP
All quality score lines for a given quality score must have the same length
except for the last (not sure why there is this limitation). This is not
problematic for sequences but could be annoying for quality scores. A workaround
is to make sure the your quality scores fit on no more than 2 lines. Another
solution could be to padd them with blank spaces so that each line has the same
number of characters (maybe this padding should be implemented in
Bio::SeqIO::qual?).
.SH "AUTHOR"
.IX Header "AUTHOR"
Florent E Angly <florent . angly @ gmail\-dot\-com>.
.PP
Module largely based on and adapted from Bio::DB::Fasta by Lincoln Stein.
.PP
Copyright (c) 2007 Florent E Angly.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : my $db = Bio::DB::Qual\->new( $path, @options);
\& Function: initialize a new Bio::DB::Qual object
\& Returns : new Bio::DB::Qual object
\& Args    : path to dir of qual files or a single qual filename
.Ve
.PP
These are optional arguments to pass in as well.
.PP
.Vb 3
\& \-glob         Glob expression to use    *.{qual,QUAL,qa,QA}
\&               for searching for qual
\&               files in directories. 
\&
\& \-makeid       A code subroutine for     none
\&               transforming qual IDs.
\&
\& \-maxopen      Maximum size of           32
\&               filehandle cache.
\&
\& \-debug        Turn on status            0
\&               messages.
\&
\& \-reindex      Force the index to be     0
\&               rebuilt.
\&
\& \-dbmargs      Additional arguments      none
\&               to pass to the DBM
\&               routines when tied
\&               (scalar or array ref).
.Ve
.SS "newFh"
.IX Subsection "newFh"
.Vb 5
\& Title   : newFh
\& Usage   : my $fh = Bio::DB::Qual\->newFh(\*(Aq/path/to/qual/files\*(Aq);
\& Function: gets a new Fh for a file or directory containing several files
\& Returns : filehandle object
\& Args    : none
.Ve
.SS "index_dir"
.IX Subsection "index_dir"
.Vb 5
\& Title   : index_dir
\& Usage   : $db\->index_dir($dir)
\& Function: set the index dir and load all files in the dir
\& Returns : hashref of qual offsets in each file
\& Args    : dirname, boolean to force a reload of all files
.Ve
.SS "get_Qual_by_id"
.IX Subsection "get_Qual_by_id"
.Vb 5
\& Title   : get_Qual_by_id
\& Usage   : my $qual = $db\->get_Qual_by_id($id)
\& Function: Bio::DB::RandomAccessI method implemented
\& Returns : Bio::PrimarySeqI object
\& Args    : id
.Ve
.SS "set_pack_method"
.IX Subsection "set_pack_method"
.Vb 5
\& Title   : set_pack_method
\& Usage   : $db\->set_pack_method( @files )
\& Function: Determines whether data packing uses 32 or 64 bit integers
\& Returns : 1 for success
\& Args    : one or more file paths
.Ve
.SS "index_file"
.IX Subsection "index_file"
.Vb 6
\& Title   : index_file
\& Usage   : $db\->index_file($filename)
\& Function: (re)loads a quality score file and indexes quality score offsets in
\&           the file
\& Returns : qual offsets in the file
\& Args    : filename, boolean to force reloading a file
.Ve
.SS "dbmargs"
.IX Subsection "dbmargs"
.Vb 5
\& Title   : dbmargs
\& Usage   : my @args = $db\->dbmargs;
\& Function: gets stored dbm arguments
\& Returns : array
\& Args    : none
.Ve
.SS "index_name"
.IX Subsection "index_name"
.Vb 5
\& Title   : index_name
\& Usage   : my $indexname = $db\->index_name($path,$isdir);
\& Function: returns the name of the index for a specific path 
\& Returns : string
\& Args    : path to check, boolean if it is a dir
.Ve
.SS "calculate_offsets"
.IX Subsection "calculate_offsets"
.Vb 5
\& Title   : calculate_offsets
\& Usage   : $db\->calculate_offsets($filename,$offsets);
\& Function: calculates the quality score offsets in a file based on ID
\& Returns : offset hash for each file
\& Args    : file to process, $offsets \- hashref of id to offset storage
.Ve
.SS "get_all_ids"
.IX Subsection "get_all_ids"
.Vb 5
\& Title   : get_all_ids
\& Usage   : my @ids = $db\->get_all_ids
\& Function: gets all the stored ids in all indexes
\& Returns : list of ids
\& Args    : none
.Ve
.SS "length"
.IX Subsection "length"
.Vb 5
\& Title   : length
\& Usage   : $qualdb\->length($seqid);
\& Function: gets the number of quality values in a quality score
\& Returns : scalar
\& Args    : ID of a quality score
.Ve
.SS "subqual"
.IX Subsection "subqual"
.Vb 6
\& Title   : subqual
\& Usage   : my @qualarr = @{$qualdb\->subqual($id,$start,$stop)};
\& Function: returns a subqual of a quality score in the database
\& Returns : subquality array reference
\& Args    : id of quality score, starting quality value number, ending quality
\&           value number
.Ve
.SS "header"
.IX Subsection "header"
.Vb 5
\& Title   : header
\& Usage   : $qualdb\->header($id);
\& Function: returns the header of a quality score in the database
\& Returns : header string
\& Args    : id of quality score
.Ve
.SS "get_PrimaryQual_stream"
.IX Subsection "get_PrimaryQual_stream"
.Vb 5
\& Title   : get_PrimaryQual_stream
\& Usage   : $qualdb\->get_PrimaryQual_stream
\& Function: get a SeqIO\-like stream of quality scores 
\& Returns : stream object
\& Args    : none
.Ve
